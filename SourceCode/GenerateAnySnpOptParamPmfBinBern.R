# Generates from correlated binomials according to the input parameters
# Uses an optimization method to get an appropriate pmf to generate 
# multivariate binomial values directly from
GenerateAnySnpOptParamBinomial <- function(
  pAllele = c(0.1, 0.1, 0.1),
  matTargetCor = diag(3),
  nObs = 500
){
  # pAllele = The minor allele frequency of each SNP in order
  # matTargetCor = The target correlation matrix
  # nObs = the number of observations to generate
  
  # Generate integer values from the pmf generated by the method
  pmf <- calcOptPmfAnySnpBinomial(pAllele, matTargetCor)
  
  if (isTRUE(all.equal(sum(pmf), 0))) {
    return(matrix(NA, ncol = length(pAllele), nrow = nObs))
  }
  
  genIntVals <- genBag(nObs, pmf)
  
  # Constructs the Map between the integer values and the binomial values
  # for each SNP. 
  # Each column is a SNP, each row is a  value, 
  # each entry is the appropriate
  # binomial value for the integer value.
  # Note that the first column of the map matrix corresponds to the last snp,
  # The second column of the map matrix is the second last snp...
  # ....
  # The last column of the map matrix is the first snp
  # Snp naming convention is
  
  # Example of naming convention for 3 SNPs together
  # 111, 112, 113, 121, 122, 123, 131, 132, 133,
  # 211, 212, 213, 221, 222, 223, 231, 232, 233
  # 311, 312, 313, 321, 322, 323, 331, 332, 333
  
  # Corresponding values are
  # 1, 2, 3, 4, 5, 6, 7, 8, 9, 
  # 10, 11, 12, 13, 14, 15, 16, 17, 18
  # 19, 20, 21, 22, 23, 24, 25, 26, 27
  numSnp <- length(pAllele)
  mapIntToBin <- sapply(c(1:numSnp), function(snpInd){
    inner <- 3 ^ (snpInd - 1)
    outer <- 3 ^ (numSnp - snpInd)
    eexp <- snpInd - 1
    toAdd <- rep(
      c(rep(0, inner),
        rep(1, inner),
        rep(2, inner)),
      outer
    )
    
    return(toAdd)
  })
  
  # Reverse Ordering so SNP1 corresponds to column 1
  mapIntToBinOrdered <- mapIntToBin[,ncol(mapIntToBin):1]
  
  # use a simple apply to get the binomial values using the mapping
  multiBinomialVals <- apply(mapIntToBinOrdered, 2, function(colMap){
    colMap[genIntVals]
  })
  
  return(multiBinomialVals)
}

# nObs <- 5000
# p1 <- 0.1; p2 <- 0.12; p3 <- 0.15
# t12 <- 0.1; t13 <- 0.13; t23 <- 0.15
# pAllele <- c(p1, p2, p3)
# matTarCor <- diag(3)
# matTarCor[upper.tri(matTarCor)] <- c(t12,t13,t23)
# matTarCor[lower.tri(matTarCor)] <- c(t12,t13,t23)
# zz <- GenerateAnySnpOptParamBinomial(pAllele, matTarCor, nObs)
# 
# sapply(c(1:length(pAllele)), function(i){
#   table(zz[,i])/nObs
# })
# 
# cor(zz[,1], zz[,2]); cor(zz[,1], zz[,3]); cor(zz[,2], zz[,3])

# Generates correlated Bernoulli's according to the input parameters
# Uses the optimization method to get an appropriate
# Independently generates twice the number of multivariate bernoulli values 
# such that they can be added component wise to get 
# binomial marginal distributions
GenerateAnySnpOptParamBernoulli <- function(
  pAllele = c(0.1, 0.1, 0.1),
  matTargetCor = diag(3),
  nObs = 500
){
  # pAllele = The minor allele frequency of each SNP in order
  # matTargetCor = The target correlation matrix
  # nObs = the number of observations to generate
  
  # Generate integer values from the pmf generated by the method
  # We'll generate all the needed bernoulli values at once, 
  # separate them at the end and add them to get binomial values
  pmf <- calcOptPmfAnySnpBernoulli(pAllele, matTargetCor)
  
  if (isTRUE(all.equal(sum(pmf), 0))) {
    return(matrix(NA, ncol = length(pAllele), nrow = nObs))
  }
  
  genIntVals <- genBag(2*nObs, pmf)
  
  # Constructs the Map between the integer values and the binomial values
  # for each SNP. 
  # Each column is a SNP, each row is an 
  # integer value, each entry is the appropriate binomial value for 
  # the integer value.
  # Note that the first column of the map matrix corresponds to the last snp,
  # The second column of the map matrix is the second last snp...
  # ....
  # The last column of the map matrix is the first snp
  # Snp naming convention is
  
  # Example of naming convention for 3 SNPs together
  # 111, 112, 121, 122, 211, 212, 221, 222

  # Corresponding integer values are
  # 1, 2, 3, 4, 5, 6, 7, 8
  numSnp <- length(pAllele)
  mapIntToBern <- sapply(c(1:numSnp), function(snpInd){
    inner <- 2 ^ (snpInd - 1)
    outer <- 2 ^ (numSnp - snpInd)
    eexp <- snpInd - 1
    toAdd <- rep(
      c(rep(0, inner),
        rep(1, inner)),
      outer
    )
    
    return(toAdd)
  })
  
  # Reverse Ordering so SNP1 corresponds to column 1
  mapIntToBernOrdered <- mapIntToBern[,ncol(mapIntToBern):1]
  
  # use a simple apply to get the bernoulli values using the mapping
  multiBernVals <- apply(mapIntToBernOrdered, 2, function(colMultiMap){
    colMultiMap[genIntVals]
  })
  
  # Add the halves of the bernoulli values together to get binomial values
  multiBinVals <- apply(multiBernVals, 2, function(colBernVal){
    (colBernVal[1:nObs] + colBernVal[(nObs + 1): length(colBernVal)])
  })
  
  return(multiBinVals)
}

# nObs <- 10000000
# p1 <- 0.1; p2 <- 0.12; p3 <- 0.15
# t12 <- 0.1; t13 <- 0.13; t23 <- 0.15
# pAllele <- c(p1, p2, p3)
# matTarCor <- diag(3)
# matTarCor[upper.tri(matTarCor)] <- c(t12,t13,t23)
# matTarCor[lower.tri(matTarCor)] <- c(t12,t13,t23)
# zz <- GenerateAnySnpOptParamBernoulli(pAllele, matTarCor, nObs)
# 
# sapply(c(1:length(pAllele)), function(i){
#   table(zz[,i])/nObs
# })
# 
# cor(zz[,1], zz[,2]); cor(zz[,1], zz[,3]); cor(zz[,2], zz[,3])

